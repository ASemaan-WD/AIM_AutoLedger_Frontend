/**
 * Upload Service
 * NEW FLOW: Upload directly to Vercel Blob, create Airtable record
 * 
 * Error Handling:
 * - If Vercel Blob upload fails: Nothing to clean up
 * - If Airtable creation fails: Orphaned blob (cleaned up via backend)
 */

import { uploadToBlob } from '@/lib/vercel-blob';
import { createRecords } from './airtable-service';
import { generateArrayBufferHash } from '@/utils/file-hash';
import { checkFileHashDuplicate } from '@/lib/duplicate-detection';
import { validatePageCount, MAX_PDF_PAGES } from '@/utils/file-validation';

export interface UploadResponse {
  success: boolean;
  url?: string;
  filename?: string;
  size?: number;
  type?: string;
  fileId?: number; // Numeric FileID from Airtable
  airtableRecordId?: string; // Airtable record ID (recXXXX)
  ocrJobId?: number; // OCR job ID returned from backend
  pageCount?: number; // Number of pages in the document
  error?: string;
  errorCode?: string;
  errorMessage?: string;
  duplicateRecordId?: string; // Airtable record ID of the duplicate file
  duplicateFileName?: string; // Name of the duplicate file
}

/**
 * Upload a file - New Flow
 * 
 * Steps:
 * 1. Calculate file hash (SHA-256) for duplicate detection
 * 2. Check if hash already exists in Airtable (prevent duplicates)
 * 3. Upload file to Vercel Blob Storage
 * 4. Create File record in Airtable (Status: Queued, Processing-Status: UPL)
 * 
 * Note: PDF conversion and OCR triggering should be handled by the caller
 * 
 * @param file - File to upload (PDF)
 * @param signal - Optional AbortSignal to cancel the upload
 * @returns Upload response with file info
 */
export async function uploadFile(file: File, signal?: AbortSignal): Promise<UploadResponse> {
  try {
    // Check if already aborted
    if (signal?.aborted) {
      throw new DOMException('Upload cancelled', 'AbortError');
    }

    // Step 1: Calculate file hash for duplicate detection
    console.log('üî¢ Step 1: Calculating file hash...');
    const fileBuffer = await file.arrayBuffer();
    const fileHash = await generateArrayBufferHash(fileBuffer);
    console.log('‚úÖ File hash:', fileHash);

    // Step 2: Check for duplicate hash BEFORE uploading
    console.log('üîç Step 2: Checking for duplicate files...');
    const baseId = import.meta.env.VITE_AIRTABLE_BASE_ID;
    if (!baseId) {
      throw new Error('VITE_AIRTABLE_BASE_ID not configured');
    }
    
    const duplicateCheck = await checkFileHashDuplicate(fileHash, baseId);
    if (duplicateCheck.isDuplicate && duplicateCheck.duplicateRecord) {
      console.warn('‚ö†Ô∏è  Duplicate file detected:', duplicateCheck.duplicateRecord.name);
      return {
        success: false,
        error: 'Duplicate file detected',
        errorCode: 'DUPLICATE_FILE',
        errorMessage: duplicateCheck.reason || 'This file has already been uploaded',
        duplicateRecordId: duplicateCheck.duplicateRecord.id,
        duplicateFileName: duplicateCheck.duplicateRecord.name,
      };
    }
    console.log('‚úÖ No duplicates found');

    // Step 2.5: Validate page count (max 30 pages for PDFs)
    console.log('üìÑ Step 2.5: Validating page count...');
    const pageCountResult = await validatePageCount(file, MAX_PDF_PAGES);
    if (!pageCountResult.isValid) {
      console.warn('‚ö†Ô∏è  Page count validation failed:', pageCountResult.errorMessage);
      return {
        success: false,
        error: 'Too many pages',
        errorCode: 'TOO_MANY_PAGES',
        errorMessage: pageCountResult.errorMessage || `File exceeds maximum of ${MAX_PDF_PAGES} pages`,
      };
    }
    const pageCount = pageCountResult.pageCount || 1;
    console.log(`‚úÖ Page count valid: ${pageCount} pages`);

    // Step 3: Upload to Vercel Blob
    console.log('üì§ Step 3: Uploading to Vercel Blob...');
    // Pass just the filename - uploadToBlob will add timestamp and random suffix
    const blobResult = await uploadToBlob(file, `uploads/${file.name}`, {}, signal);
    console.log('‚úÖ Uploaded to Vercel:', blobResult.url);

    // Step 4: Create File record in Airtable
    console.log('üìù Step 4: Creating File record in Airtable...');
    let airtableResponse;
    let createdRecord;
    
    try {
      airtableResponse = await createRecords('Files', {
        fields: {
          'FileName': file.name,
          'FileHash': fileHash,
          'FileURL': blobResult.url,
          'Status': 'Queued',
          'Processing-Status': 'UPL',
          'UploadedDate': new Date().toISOString().split('T')[0],
          'Pages': pageCount, // Store the page count
          'Attachments': [
            {
              url: blobResult.url,
              filename: file.name,
            }
          ],
          // Note: FileID is auto-generated by Airtable
          // Note: 'Source' field was removed from Files table schema
        },
      });

      createdRecord = airtableResponse.records[0];
      if (!createdRecord) {
        throw new Error('Failed to create Airtable record');
      }

      console.log('‚úÖ Created Airtable record:', createdRecord.id);
      
    } catch (airtableError) {
      // If Airtable creation fails, we have an orphaned blob
      console.error('‚ùå Airtable record creation failed');
      console.warn(
        '‚ö†Ô∏è  WARNING: Orphaned blob created at:', blobResult.url,
        '\n  This blob exists in Vercel but has no Airtable record.',
        '\n  It should be cleaned up via backend/manual cleanup.'
      );
      
      // Note: We cannot delete the blob from the browser due to CORS restrictions.
      // Vercel Blob's del() function only works server-side.
      // The blob will need to be cleaned up via:
      // 1. Backend cleanup endpoint (Azure Functions)
      // 2. Manual cleanup via Vercel dashboard
      // 3. Periodic cleanup script
      
      throw airtableError; // Re-throw the original Airtable error
    }

    // Get the numeric FileID from the created record
    const fileId = createdRecord.fields['FileID'] as number;
    if (!fileId) {
      throw new Error('FileID not found in created Airtable record');
    }
    console.log('‚úÖ FileID:', fileId);

    // Return success immediately - caller can handle PDF conversion and OCR
    return {
      success: true,
      url: blobResult.url,
      filename: file.name,
      size: file.size,
      type: file.type,
      fileId,
      airtableRecordId: createdRecord.id,
      pageCount, // Include page count in response
    };

  } catch (error) {
    console.error('‚ùå Upload failed:', error);
    
    // If it's an abort error, provide specific message
    if (error instanceof DOMException && error.name === 'AbortError') {
      return {
        success: false,
        error: 'Upload cancelled by user',
        errorMessage: 'Upload cancelled',
      };
    }
    
    return {
      success: false,
      error: error instanceof Error ? error.message : 'Upload failed',
      errorMessage: error instanceof Error ? error.message : 'Unknown error',
    };
  }
}

